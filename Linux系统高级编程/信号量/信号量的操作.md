所谓的信号量，也称为信号灯集。不能直接实现多任务之间的数据的通信，用于解决多任务之间资源的互斥和任务的同步。

信号量实质是非负整数

如果信号量的值大于零，表示有资源可以访问，便访问资源，并将资源数减一操作；

如果信号量的值等于零，表示无资源可以访问，任务阻塞等待，直到信号大于零继续执行。

**2 信号量的操作**

## **2.1 创建信号量**

信号量存储在内存空间中，需要使用函数semget创建获取

1. 函数原型

```c
#include <sys/types.h>
#include <sys/ipc.h> #include
<sys/sem.h> int semget(key_t key, int nsems, int semflg);
```

#### 功能：

​	创建或者获取内存中的信号量

#### 参数：

参数1：key system V IPC对象中的键值

​		IPC_PRIVATE：所创建的信号量为私有信号量，每次调用都会创建新的信号量；

​		非IPC_PRIVATE：在信号量不存在的创建并获取信号量，在存在的时候获取信号量；

参数2：nsems表示信号灯集中信号量的个数。

参数3：semflg表示获取信号量行为和权限

​	IPC_CREAT	：信号量不存在则创建信号量，存在则直接获取信号量；

​	IPC_EXCL	   ：在创建信号量的时候使用，表示信号量已存在则报错，否则创建。

访问权限的设置和open函数一致。

#### 返回值：

​	成功返回信号量的ID，失败返回-1且修改errno的值。

## **2.2 控制信号量**

1. semctl函数原型

```c
#include <sys/types.h> 
#include <sys/ipc.h> #include <sys/sem.h> 
int semctl(int semid, int semnum, int cmd, ...);
```

#### 功能：

实现对信号量的控制操作

#### 参数：

参数1：semid为信号量标识符ID

参数2：semnum表示信号量序号(从0开始计数)。

参数3：cmd信号量的操作命令

​	IPC_STAT		：获取信号量集合的属性

​	IPC_SET		：设置信号量集合的属性

​	IPC_RMID	     ：删除信号量集合，此时的semnum只要在取值范围内即可；

​	GETVAL		：获取信号量集合中某信号量的值

​	SETVAL		：获取信号量集合中某信号量的值

注意：参数cmd决定后续的可变参数

```c
union semun {  
     int val; 				  /* Value for SETVAL */    
     struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */    
     unsigned short  *array;  /* Array for GETALL, SETALL */   
     struct seminfo  *__buf;  /* Buffer for IPC_INFO       (Linux-specific) */ 
};
```

1. 信号量控制实例

```c
#include<stdio.h> 
#include<sys / types.h> 
#include<sys / ipc.h> 
#include<sys / sem.h> 
union semun
{
      int val;        /* Value for SETVAL */
      struct semid_ds *buf;  /* Buffer for IPC_STAT, IPC_SET */
      unsigned short *array; /* Array for GETALL, SETALL */
      struct seminfo *__buf; /* Buffer for IPC_INFO   (Linux-specific) */

};

#define SEM_COUNT 4 
int main()
{
  int i;
  int semid;
  key_t key;
  union semun mysemun; /* 获取 key */
  key = ftok(".", 's');
  if (key == -1)
  {
    perror("ftok");
    return -1;
  } /* 创建信号量 */
  semid = semget(key, SEM_COUNT, IPC_CREAT | 0777);
  if (semid == -1)
  {
    perror("semget");
    return -1;
  } /* 初始化信号量集合中的信号量的初始值 */
  for (i = 0; i < SEM_COUNT; i++)
  {
    mysemun.val = i + 1;
    if (-1 == semctl(semid, i, SETVAL, mysemun))
    {
      perror("semctl->IPC_RMID");
      return -1;
    }
  } /* 读取信号量集合中的信号量值 */
  for (i = 0; i < SEM_COUNT; i++)
  {
    printf("%d\n", semctl(semid, i, GETVAL));
  } /* 删除信号量集合 */
  if (-1 == semctl(semid, 0, IPC_RMID))
  {
    perror("semctl->IPC_RMID");
    return -1;

  }

}
```

## **2.3 信号量的PV控制**

#### **2.3.1 PV操作的概述**

1. P操作

P操作，指的是信号量-1操作，

判断信号量值：

如果信号量值 大于零 则信号量减一操作；

如果信号量值 等于零 则任务阻塞等待，直到被同一个信号量的其它任务唤醒，当前任务继续执行；

1. V操作

V操作，指的是信号量+1操作

判断信号量是否有阻塞其它任务

如果有任务阻塞，唤醒被阻塞的任务的执行；

如果没有任务阻塞，将信号量的值加一操作。

#### **2.3.2 PV操作的实现**

1. 函数原型

```c
#include <sys/types.h> 
#include <sys/ipc.h> 
#include <sys/sem.h> 
int semop(int semid, struct sembuf *sops, size_t nsops);
```

#### 参数：

参数1：semid表示信号量集合ID；

参数2：sops结构体指针

参数3：nsops表示要操作信号量的个数