地址映射（Address Mapping）是操作系统中**将虚拟地址转换为物理地址**的核心机制，目的是让进程通过 “虚拟地址” 安全、方便地访问实际的物理内存，同时实现内存隔离、地址空间扩展等功能。

### 一、核心概念：虚拟地址 vs 物理地址

- **物理地址**：内存硬件（如内存条）实际存在的地址，是 CPU 通过地址总线直接访问内存的编号（例如 `0x12345678` 对应内存芯片中的某一存储单元）。
- **虚拟地址**：进程运行时看到的 “逻辑地址”，由操作系统分配，与物理内存的实际位置无关（例如进程中的变量 `int a` 的地址 `0x7f80abc1234` 是虚拟地址）。

地址映射的作用：**将进程使用的虚拟地址，动态转换为内存硬件能识别的物理地址**，让进程无需关心物理内存的实际布局。

### 二、为什么需要地址映射？

没有地址映射时，进程直接使用物理地址会导致严重问题：

1. **内存冲突**：多个进程可能同时使用同一个物理地址，导致数据被覆盖（例如进程 A 和 B 都想使用 `0x1000` 地址）。
2. **内存隔离**：进程能随意访问其他进程的物理内存，安全性无法保证。
3. **地址空间限制**：进程可用内存受限于物理内存大小（例如物理内存只有 4GB，进程无法使用超过 4GB 的地址）。

地址映射通过 “虚拟地址” 为每个进程提供**独立的、连续的地址空间**，解决了上述问题。

### 三、地址映射的实现：页表与 MMU

现代操作系统通过**页表（Page Table）** 和**内存管理单元（MMU）** 实现地址映射，核心步骤如下：

1. **内存分页**：

   虚拟地址空间和物理内存被划分为固定大小的 “页（Page）”（通常 4KB）。例如：

   - 虚拟地址 → 分为 “虚拟页号（VPN）” 和 “页内偏移（Offset）”；
   - 物理地址 → 分为 “物理页号（PPN）” 和 “页内偏移（Offset）”。

   页内偏移在映射时保持不变（因为页大小固定），只需转换页号。

2. **页表（Page Table）**：

   操作系统为每个进程维护一张 “页表”，本质是**虚拟页号到物理页号的映射表**。例如：

   - 虚拟页号 `0` → 物理页号 `5`（表示虚拟地址的第 0 页对应物理内存的第 5 页）；
   - 虚拟页号 `1` → 物理页号 `10`；
   - 未使用的虚拟页号 → 标记为 “无效”（访问时触发缺页中断）。

3. **MMU 硬件转换**：

   CPU 中的**内存管理单元（MMU）** 是专门负责地址映射的硬件：

   - 进程访问虚拟地址时，MMU 自动提取 “虚拟页号”；
   - 查页表，将虚拟页号转换为 “物理页号”；
   - 结合 “页内偏移”，生成最终的物理地址，访问物理内存。

   整个过程由硬件自动完成，对进程透明（进程感知不到映射的存在）。

### 四、举例：地址映射的具体过程

假设：

- 页大小为 4KB（即页内偏移占 12 位，`2^12=4096`）；

- 虚拟地址

  ```
  0x12345678
  ```

  分解为：

  - 虚拟页号（高 20 位）：`0x12345`
  - 页内偏移（低 12 位）：`0x678`

映射步骤：

1. MMU 从虚拟地址中提取虚拟页号 `0x12345`；
2. 查进程的页表，发现 `0x12345` 对应物理页号 `0xabcde`；
3. 物理地址 = 物理页号 `0xabcde` × 4KB + 页内偏移 `0x678` → `0xabcde678`；
4. CPU 通过物理地址 `0xabcde678` 访问实际内存。

### 五、地址映射的关键作用

1. **内存隔离**：每个进程有独立的页表，虚拟地址空间互不干扰（进程 A 的虚拟页 `0` 和进程 B 的虚拟页 `0` 可映射到不同物理页）。
2. **地址空间扩展**：通过虚拟地址，进程可使用远大于物理内存的地址空间（例如 32 位进程可使用 4GB 虚拟地址，即使物理内存只有 2GB），未使用的虚拟页无需映射到物理内存。
3. **内存共享**：多个进程的虚拟页可映射到同一个物理页（如共享库、共享内存），实现数据共享。
4. **内存保护**：页表项可标记权限（如 “只读”“可执行”），防止进程越权访问（例如修改只读代码段会触发异常）。

### 总结

地址映射是操作系统通过 “虚拟地址→物理地址” 的转换，为进程提供安全、独立、灵活的内存访问方式的核心机制。其本质是**通过页表和 MMU 硬件，屏蔽物理内存的细节，让进程专注于逻辑地址空间的使用**，是现代操作系统内存管理的基石。