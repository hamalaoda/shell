## *ftok函数*：

1. **作用：**

   - 生成 Sytem V IPC 键值（Key）的函数；key的作用是将一个<font color='red'>已存在的文件路径</font>和<font color='red'>一个整数标识符（proj_id）</font>映射为一个唯一的键值，供消息队列、共享内存、信号量等Sytem V IPC机制使用。

2. **函数原型**：

   - ```c
     #include <sys/types.h>
     #include <sys/ipc.h>
     
     key_t ftok(const char *pathname, int proj_id);
     ```

   - **参数说明：**

     1. pathname：

        指向一个已存在的文件路径（必须是可访问的）

        该文件用于ftok获取并生成键值的基础信息（通常使用文件的索引节点号`inode`）

     2. proj_id：

        一个 8 位整数（取值范围通常0-255），作为项目标识符相同路径下，不同的`proj_id`可生成不同的键值

   - **返回值：**

     - 成功：

       返回一个非负的 key_t类型键值；

     - 失败：

       返回 -1并设置 `errno` 表示错误原因（如文件不存在、权限不足等）。

   - **工作原理：**

     `ftok` 生成键值的逻辑大致为：

     1. 获取 `pathname` 对应文件的 **索引节点号（inode）**。
     2. 取 `proj_id` 的低 8 位（确保其为 8 位整数）。
     3. 将 inode 号的部分位与 proj_id 的低 8 位组合，生成唯一的 `key_t` 键值。

     - **实例：**

       ```c
       #include <stdio.h>
       #include <sys/types.h>
       #include <sys/ipc.h>
       
       int main(int argc, char const *argv[])
       {
           key_t key;
           /*以当前目录（.）和proj_id=65生成键值*/
           key = ftok(".", 65);
           if (key == -1)
           {
               perror("ftok failed");
               return -1;
           }
           printf("key = %d", key);
       
           return 0;
       }
       ```

   **注意事项:**

   1. **文件必须存在**：`pathname` 指向的文件必须存在且可访问，否则会失败。
   2. **键值唯一性并非绝对**：不同的 `pathname` 和 `proj_id` 可能生成相同的键值（哈希冲突），但概率极低。
   3. **与文件 inode 强关联**：若文件被删除重建，inode 变化，键值也会变化，可能导致 IPC 资源无法共享。
   4. `key` 不是队列 ID，仅用于 “找队列”；最终操作队列用 `msgget` 返回的 `msgid`。



查看消息队列

ipcs -q

删除消息队列

ipcrm -q msqid



## 1、*创建消息队列*

`msgget` 函数是 Unix/Linux 系统中用于<font color='red'>创建或获取</font> **System V 消息队列** 的函数，它通过 `ftok` 生成的键值（Key）来标识消息队列，是进程间通过消息队列通信的第一步。

### msgget函数原型

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
```

### 参数说明

1. **key**：`key_t` 类型的键值（通常由 `ftok` 生成），用于标识消息队列(消息队列的索引)。
   - 若 `key` 为 `IPC_PRIVATE`（值为 0），则创建一个仅当前进程（或其子孙进程）可见的私有消息队列（键值不对外暴露）。
2. **msgflg**：标志位，用于指定创建或获取消息队列的行为，常用取值：
   - **`IPC_CREAT`**：若 `key` 对应的消息队列不存在，则创建它；若已存在，则直接获取。
   - **`IPC_EXCL`**：与 `IPC_CREAT` 配合使用（`IPC_CREAT | IPC_EXCL`），确保创建一个全新的消息队列（若已存在则返回错误，避免误获取）。
   - **权限位**：需指定消息队列的访问权限（如 `0666` 表示所有用户可读可写），格式与文件权限相同。（每个权限占3位；文件所有者、同组成员、其他成员）

### 返回值

- 成功：返回一个非负整数（**消息队列 ID**），后续操作（如发送 / 接收消息）需通过该 ID 标识队列。
- 失败：返回 `-1`，并设置 `errno` 表示错误原因（如权限不足、队列已存在且使用 `IPC_EXCL` 等）。

### 核心作用

- **创建消息队列**：当 `key` 不存在且指定 `IPC_CREAT` 时，新建一个消息队列并返回其 ID。
- **获取已有队列**：当 `key` 已对应一个消息队列时，直接返回其 ID（需有访问权限）。

### 示例

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int main() {
    key_t key;
    int msgid;

    // 生成键值（基于当前目录和 proj_id=65）
    key = ftok(".", 65);
    if (key == -1) {
        perror("ftok failed");
        return  1;
    }

    // 创建消息队列（权限 0666，若不存在则创建，存在则获取）
    msgid = msgget(key, IPC_CREAT | 0666);
    if (msgid == -1) {
        perror("msgget failed");
        return 1;
    }

    printf("Message queue created/opened, ID: %d\n", msgid);
    return 0;
}
```

### 注意事项

1. **权限控制**：消息队列的权限需合理设置，避免未授权进程访问。
2. **`IPC_PRIVATE` 的使用**：若用 `IPC_PRIVATE` 作为 `key`，创建的队列仅能通过进程间的继承关系（如父子进程）共享（因为键值不对外可见）。
3. **队列的生命周期**：消息队列不会随进程退出而自动删除，需通过 `msgctl` 函数显式删除（使用 `IPC_RMID` 命令），否则会残留系统中占用资源。

例如，删除消息队列的代码片段：

```c
// 销毁消息队列（需有足够权限）
if (msgctl(msgid, IPC_RMID, NULL) == -1) {
    perror("msgctl failed");
}
```

`msgget` 是消息队列通信的基础，后续的 `msgsnd`（发送消息）和 `msgrcv`（接收消息）均依赖它返回的消息队列 ID。

------



## 2、*发送消息*

`msgsnd` 函数是 Unix/Linux 系统中用于向 **System V 消息队列** 发送消息的函数，它通过消息队列 ID（`msgid`）指定目标队列，并将消息写入队列中，供其他进程通过 `msgrcv` 读取。

### 函数原型

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```

### 参数说明

1. **msqid**：消息队列 ID（由 `msgget` 函数返回），指定要发送消息的目标队列。

2. msgp

   ：指向消息缓冲区的指针，消息结构需满足

   首字段为 `long mtype`

   （消息类型，必须 ≥ 1），后续字段为自定义消息内容。

   示例消息结构：

   ```c
   struct msgbuf {
       long mtype;       // 消息类型（用于接收时筛选）
       char mtext[1024]; // 消息内容（自定义）
   };
   ```

3. msgsz

   ：消息内容的长度（即msgp中除mtype外的数据部分长度，单位：字节）。

   例如，上述struct msgbuf中mtext的长度为1024，则 msgsz 应设为1024（或sizeof(msgbuf.mtext)）。

4. msgflg

   ：发送消息的标志位，常用取值：

   - `0`：默认行为，若队列已满则阻塞等待，直到有空间或被信号中断。
   - `IPC_NOWAIT`：非阻塞模式，若队列已满则立即返回 `-1`，并设置 `errno` 为 `EAGAIN`。

### 返回值

- 成功：返回 `0`（消息已成功写入队列）。
- 失败：返回 `-1`，并设置 `errno` 表示错误原因（如队列不存在、权限不足、队列满且用了 `IPC_NOWAIT` 等）。

### 核心作用

将 `msgp` 指向的消息（包含类型和内容）发送到 `msqid` 标识的消息队列中，消息在队列中按 **发送顺序** 存储，接收方通过 `msgrcv` 可按类型筛选消息。

### 示例

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>

// 定义消息结构
struct msgbuf {
    long mtype;
    char mtext[1024];
};

int main() {
    key_t key;
    int msgid;
    struct msgbuf msg;

    // 生成键值并获取消息队列 ID
    key = ftok(".", 65);
    
    if (key == -1) 
    { 
        perror("ftok");
        return -1; 
    }
    msgid = msgget(key, IPC_CREAT | 0666);
    
    if (msgid == -1) 
    {
        perror("msgget");
        return -1; 
    }

    // 准备消息（类型为 1，内容为 "Hello, Message Queue!"）
    msg.mtype = 1;
    strcpy(msg.mtext, "Hello, Message Queue!");

    // 发送消息（阻塞模式）
    if (msgsnd(msgid, &msg, sizeof(msg.mtext), 0) == -1) {
        perror("msgsnd failed");
        return 1;
    }
    printf("Message sent: %s\n", msg.mtext);

    return 0;
}
```

### 注意事项

1. **消息类型约束**：`mtype` 必须 ≥ 1，否则 `msgsnd` 会失败（`errno` 为 `EINVAL`）。
2. **消息大小限制**：系统对单条消息的最大长度有上限（可通过 `MSGMAX` 宏查看，通常为 8192 字节），超过则失败。
3. **队列容量限制**：消息队列的总字节数不能超过系统上限（`MSGMNB` 宏），否则满队列时 `msgsnd` 会阻塞（默认）或返回错误（`IPC_NOWAIT`）。
4. **权限检查**：发送进程需对消息队列有写权限（否则失败，`errno` 为 `EACCES`）。

`msgsnd` 是消息队列通信中 “发送方” 的核心函数，与 “接收方” 的 `msgrcv` 配合实现进程间的异步消息传递。

------



## 3、*接收消息*

`msgrcv` 函数是 Unix/Linux 系统中用于从 **System V 消息队列** 接收消息的函数，它通过消息队列 ID（`msgid`）指定目标队列，并从队列中读取符合条件的消息到缓冲区中。

### 函数原型

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```

### 参数说明

1. **msqid**：消息队列 ID（由 `msgget` 返回），指定要读取的消息队列。

2. **msgp**：指向接收消息的缓冲区指针，结构需与发送方一致（首字段为 `long mtype`，后续为自定义内容）。

3. **msgsz**：接收缓冲区中消息内容的最大长度（即除 `mtype` 外的数据部分长度，超过则截断或失败，取决于标志位）。

4. msgtyp

   ：指定要接收的消息类型，决定筛选逻辑：

   - `msgtyp = 0`：接收队列中 **第一个消息**（不筛选类型）。
   - `msgtyp > 0`：接收队列中 **类型等于 `msgtyp` 的第一个消息**。
   - `msgtyp < 0`：接收队列中 **类型小于或等于 `|msgtyp|` 的最小类型消息**。

5. msgflg

   ：接收消息的标志位，常用取值：

   - `0`：默认行为，若队列中无符合条件的消息则阻塞等待，直到有消息或被信号中断。
   - `IPC_NOWAIT`：非阻塞模式，若无符合条件的消息则立即返回 `-1`，并设置 `errno` 为 `ENOMSG`。
   - `MSG_NOERROR`：若消息内容长度超过 `msgsz`，则截断消息（仅保留前 `msgsz` 字节），不返回错误；否则（无此标志）会失败（`errno` 为 `E2BIG`）。

### 返回值

- 成功：返回实际读取的消息内容长度（字节数，不含 `mtype` 字段）。
- 失败：返回 `-1`，并设置 `errno` 表示错误原因（如队列不存在、权限不足、无消息且用了 `IPC_NOWAIT` 等）。

### 核心作用

从 `msqid` 标识的消息队列中，按 `msgtyp` 筛选出符合条件的消息，读取到 `msgp` 缓冲区中，并从队列中移除该消息（即消息一旦被接收就会从队列中删除）。

### 示例

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>

// 与发送方一致的消息结构
struct msgbuf {
    long mtype;
    char mtext[1024];
};

int main() {
    key_t key;
    int msgid;
    struct msgbuf msg;
    ssize_t nbytes;

    // 生成键值并获取消息队列 ID（需与发送方使用相同的 key）
    key = ftok(".", 65);
    if (key == -1) { perror("ftok"); return 1; }
    msgid = msgget(key, 0666); // 仅获取已有队列（不创建）
    if (msgid == -1) { perror("msgget"); return 1; }

    // 接收类型为 1 的消息（阻塞模式，缓冲区足够大）
    nbytes = msgrcv(msgid, &msg, sizeof(msg.mtext), 1, 0);
    if (nbytes == -1) {
        perror("msgrcv failed");
        return 1;
    }

    printf("Received message (type %ld): %s\n", msg.mtype, msg.mtext);
    printf("Received %zd bytes of content\n", nbytes);

    return 0;
}
```

### 注意事项

1. **消息类型匹配**：`msgtyp` 的取值决定了接收逻辑，需与发送方的 `mtype` 配合使用（例如发送方用 `mtype=1`，接收方需指定 `msgtyp=1` 才能准确接收）。
2. **缓冲区大小**：若消息内容长度超过 `msgsz` 且未设置 `MSG_NOERROR`，`msgrcv` 会失败；设置后会截断消息，可能导致数据丢失，需谨慎使用。
3. **阻塞行为**：默认情况下，若队列中无符合条件的消息，`msgrcv` 会阻塞等待，直到有消息到达或被信号（如 `SIGINT`）中断（此时返回 `-1`，`errno` 为 `EINTR`）。
4. **权限检查**：接收进程需对消息队列有读权限（否则失败，`errno` 为 `EACCES`）。

`msgrcv` 是消息队列通信中 “接收方” 的核心函数，与发送方的 `msgsnd` 配合，实现进程间按类型筛选的异步消息传递。

